# 链表
## 0. 基础
```c++
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x): val(x), next(NULL){
    }
};
```
## 1. 经典题
### 链表逆序
- [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/description/)
```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* new_head = NULL;
        while (head) {
            ListNode* next = head->next;
            head->next = new_head;
            new_head = head;
            head = next;
        }
        return new_head;
    }
};
```
### 链表逆序（任意区间）
- [92. Reverse Linked List II])(https://leetcode.com/problems/reverse-linked-list-ii/description/)
```c++
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        int n_change = n - m + 1;
        ListNode* pre_head = NULL;
        ListNode* result = head;
        while (head && --m) {
            pre_head = head;
            head = head->next;
        }
        ListNode* modify_list_tail = head;
        ListNode* new_head = NULL;
        while (head && n_change) {
            ListNode* next = head->next;
            head->next = new_head;
            new_head = head;
            head = next;
            n_change--;
        }
        modify_list_tail->next = head;
        if (pre_head) {
            pre_head->next = new_head;
        }
        else {
            result = new_head;
        }
        return result;
    }
};
```
### 链表交点
- [160. Intersection of Two Linked Listsz](https://leetcode.com/problems/intersection-of-two-linked-lists/description/)
```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        std::set<ListNode*> node_set;
        while (headA) {
            node_set.insert(headA);
            headA = headA->next;
        }
        while (headB) {
            if (node_set.find(headB) != node_set.end())
                return headB;
            headB = headB->next;
        }
        return NULL;
    }
};
```
```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int len_listA = get_list_length(headA);
        int len_listB = get_list_length(headB);
        if (len_listA > len_listB)
            headA = forward_long_list(len_listA, len_listB, headA);
        else
            headB = forward_long_list(len_listB, len_listA, headB);
        while (headA && headB) {
            if (headA == headB)
                return headA;
            headA = headA->next;
            headB = headB->next;
        }
        return NULL;
    }
    
private:
    int get_list_length (ListNode* head) {
        int len = 0;
        while (head) {
            len++;
            head = head->next;
        }
        return len;
    }
    
    ListNode* forward_long_list (int long_len, int short_len, ListNode* head) {
        int delta = long_len - short_len;
        while (head && delta) {
            head = head->next;
            delta--;
        }
        return head;
    }
};
```
### 链表求环
### 链表划分
### 复杂链表的复制
### 2个排序链表的归并
### K个排序链表的归并
## 2. 思路总结